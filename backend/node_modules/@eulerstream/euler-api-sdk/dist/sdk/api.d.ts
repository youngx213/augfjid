/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @enum {string}
 */
export declare const ApiRoutes: {
    readonly ApiLive: "api-live";
    readonly InfoByUser: "info-by-user";
};
export type ApiRoutes = typeof ApiRoutes[keyof typeof ApiRoutes];
/**
 *
 * @export
 * @interface IAccountRequestLimits
 */
export interface IAccountRequestLimits {
    /**
     *
     * @type {number}
     * @memberof IAccountRequestLimits
     */
    'day': number;
    /**
     *
     * @type {number}
     * @memberof IAccountRequestLimits
     */
    'minute': number;
    /**
     *
     * @type {number}
     * @memberof IAccountRequestLimits
     */
    'hour': number;
}
/**
 *
 * @export
 * @interface IAlert
 */
export interface IAlert {
    /**
     *
     * @type {string}
     * @memberof IAlert
     */
    'unique_id': string;
    /**
     *
     * @type {number}
     * @memberof IAlert
     */
    'account_id': number;
    /**
     *
     * @type {number}
     * @memberof IAlert
     */
    'alert_creator_id': number;
    /**
     *
     * @type {number}
     * @memberof IAlert
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof IAlert
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof IAlert
     */
    'alert_creator_username': string;
    /**
     *
     * @type {boolean}
     * @memberof IAlert
     */
    'read_only': boolean;
}
/**
 *
 * @export
 * @interface IAlertConfigBase
 */
export interface IAlertConfigBase {
    /**
     *
     * @type {string}
     * @memberof IAlertConfigBase
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface IAlertTarget
 */
export interface IAlertTarget {
    /**
     *
     * @type {string}
     * @memberof IAlertTarget
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof IAlertTarget
     */
    'metadata'?: {
        [key: string]: any;
    };
    /**
     *
     * @type {number}
     * @memberof IAlertTarget
     */
    'alert_id': number;
    /**
     *
     * @type {number}
     * @memberof IAlertTarget
     */
    'alert_creator_id': number;
    /**
     *
     * @type {number}
     * @memberof IAlertTarget
     */
    'id': number;
    /**
     *
     * @type {IAlertTargetStatus}
     * @memberof IAlertTarget
     */
    'last_status': IAlertTargetStatus;
    /**
     *
     * @type {string}
     * @memberof IAlertTarget
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof IAlertTarget
     */
    'updated_at': string;
    /**
     *
     * @type {IAlertTargetFormat}
     * @memberof IAlertTarget
     */
    'format': IAlertTargetFormat;
    /**
     *
     * @type {number}
     * @memberof IAlertTarget
     */
    'account_id': number;
}
/**
 *
 * @export
 * @interface IAlertTargetConfigBase
 */
export interface IAlertTargetConfigBase {
    /**
     *
     * @type {string}
     * @memberof IAlertTargetConfigBase
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof IAlertTargetConfigBase
     */
    'metadata'?: {
        [key: string]: any;
    };
}
/**
 *
 * @export
 * @enum {number}
 */
export declare const IAlertTargetFormat: {
    readonly NUMBER_0: 0;
    readonly NUMBER_1: 1;
};
export type IAlertTargetFormat = typeof IAlertTargetFormat[keyof typeof IAlertTargetFormat];
/**
 *
 * @export
 * @enum {number}
 */
export declare const IAlertTargetStatus: {
    readonly NUMBER_0: 0;
    readonly NUMBER_1: 1;
    readonly NUMBER_4: 4;
};
export type IAlertTargetStatus = typeof IAlertTargetStatus[keyof typeof IAlertTargetStatus];
/**
 *
 * @export
 * @interface IAlertWithRoomInfo
 */
export interface IAlertWithRoomInfo {
    /**
     *
     * @type {string}
     * @memberof IAlertWithRoomInfo
     */
    'unique_id': string;
    /**
     *
     * @type {number}
     * @memberof IAlertWithRoomInfo
     */
    'account_id': number;
    /**
     *
     * @type {number}
     * @memberof IAlertWithRoomInfo
     */
    'alert_creator_id': number;
    /**
     *
     * @type {number}
     * @memberof IAlertWithRoomInfo
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof IAlertWithRoomInfo
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof IAlertWithRoomInfo
     */
    'alert_creator_username': string;
    /**
     *
     * @type {boolean}
     * @memberof IAlertWithRoomInfo
     */
    'read_only': boolean;
    /**
     *
     * @type {TikTokLiveRoomInfo}
     * @memberof IAlertWithRoomInfo
     */
    'room_info'?: TikTokLiveRoomInfo;
}
/**
 *
 * @export
 * @interface IApiKey
 */
export interface IApiKey {
    /**
     *
     * @type {string}
     * @memberof IApiKey
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof IApiKey
     */
    'value': string;
    /**
     *
     * @type {number}
     * @memberof IApiKey
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof IApiKey
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof IApiKey
     */
    'updated_at': string;
    /**
     *
     * @type {number}
     * @memberof IApiKey
     */
    'account_id': number;
}
/**
 *
 * @export
 * @interface IApiKeyConfig
 */
export interface IApiKeyConfig {
    /**
     *
     * @type {string}
     * @memberof IApiKeyConfig
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof IApiKeyConfig
     */
    'value': string;
}
/**
 *
 * @export
 * @interface IApiKeyConfigBase
 */
export interface IApiKeyConfigBase {
    /**
     *
     * @type {string}
     * @memberof IApiKeyConfigBase
     */
    'name': string;
}
/**
 *
 * @export
 * @interface ICountSignUsage
 */
export interface ICountSignUsage {
    /**
     *
     * @type {number}
     * @memberof ICountSignUsage
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ICountSignUsage
     */
    'message'?: string;
    /**
     *
     * @type {number}
     * @memberof ICountSignUsage
     */
    'pages'?: number;
}
/**
 *
 * @export
 * @interface ICreateAlertResponse
 */
export interface ICreateAlertResponse {
    /**
     *
     * @type {number}
     * @memberof ICreateAlertResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ICreateAlertResponse
     */
    'message'?: string;
    /**
     *
     * @type {IAlert}
     * @memberof ICreateAlertResponse
     */
    'alert'?: IAlert;
}
/**
 *
 * @export
 * @interface ICreateAlertTargetResponse
 */
export interface ICreateAlertTargetResponse {
    /**
     *
     * @type {number}
     * @memberof ICreateAlertTargetResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ICreateAlertTargetResponse
     */
    'message'?: string;
    /**
     *
     * @type {IAlertTarget}
     * @memberof ICreateAlertTargetResponse
     */
    'target'?: IAlertTarget;
}
/**
 *
 * @export
 * @interface ICreateJWTResponse
 */
export interface ICreateJWTResponse {
    /**
     *
     * @type {number}
     * @memberof ICreateJWTResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ICreateJWTResponse
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof ICreateJWTResponse
     */
    'token'?: string;
    /**
     *
     * @type {JWTConfig}
     * @memberof ICreateJWTResponse
     */
    'config'?: JWTConfig;
}
/**
 *
 * @export
 * @interface ICreateKeyResponse
 */
export interface ICreateKeyResponse {
    /**
     *
     * @type {number}
     * @memberof ICreateKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ICreateKeyResponse
     */
    'message'?: string;
    /**
     *
     * @type {IApiKey}
     * @memberof ICreateKeyResponse
     */
    'key'?: IApiKey;
}
/**
 *
 * @export
 * @interface IDeleteAlertResponse
 */
export interface IDeleteAlertResponse {
    /**
     *
     * @type {number}
     * @memberof IDeleteAlertResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IDeleteAlertResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface IDeleteAlertTargetResponse
 */
export interface IDeleteAlertTargetResponse {
    /**
     *
     * @type {number}
     * @memberof IDeleteAlertTargetResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IDeleteAlertTargetResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface IDeleteKeyResponse
 */
export interface IDeleteKeyResponse {
    /**
     *
     * @type {number}
     * @memberof IDeleteKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IDeleteKeyResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface IGetRateLimits
 */
export interface IGetRateLimits {
    /**
     *
     * @type {number}
     * @memberof IGetRateLimits
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IGetRateLimits
     */
    'message'?: string;
    /**
     *
     * @type {IRateLimitInfo}
     * @memberof IGetRateLimits
     */
    'day'?: IRateLimitInfo;
    /**
     *
     * @type {IRateLimitInfo}
     * @memberof IGetRateLimits
     */
    'hour'?: IRateLimitInfo;
    /**
     *
     * @type {IRateLimitInfo}
     * @memberof IGetRateLimits
     */
    'minute'?: IRateLimitInfo;
}
/**
 *
 * @export
 * @interface IGetSignUsageResponse
 */
export interface IGetSignUsageResponse {
    /**
     *
     * @type {number}
     * @memberof IGetSignUsageResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IGetSignUsageResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<ISignLogPublic>}
     * @memberof IGetSignUsageResponse
     */
    'usage'?: Array<ISignLogPublic>;
}
/**
 *
 * @export
 * @interface IGetSignWebcastUrlResponse
 */
export interface IGetSignWebcastUrlResponse {
    /**
     *
     * @type {number}
     * @memberof IGetSignWebcastUrlResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'signedUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'msToken'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'browserVersion'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'browserName'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    '_signature'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'X-Bogus'?: string;
    /**
     *
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'User-Agent'?: string;
}
/**
 *
 * @export
 * @interface IHostsResponse
 */
export interface IHostsResponse {
    /**
     *
     * @type {number}
     * @memberof IHostsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IHostsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<PeerPresence>}
     * @memberof IHostsResponse
     */
    'hosts'?: Array<PeerPresence>;
}
/**
 *
 * @export
 * @interface IJSONResponse
 */
export interface IJSONResponse {
    /**
     *
     * @type {number}
     * @memberof IJSONResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IJSONResponse
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface IListAlertTargetsResponse
 */
export interface IListAlertTargetsResponse {
    /**
     *
     * @type {number}
     * @memberof IListAlertTargetsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IListAlertTargetsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<IAlertTarget>}
     * @memberof IListAlertTargetsResponse
     */
    'targets'?: Array<IAlertTarget>;
}
/**
 *
 * @export
 * @interface IListAlertsResponse
 */
export interface IListAlertsResponse {
    /**
     *
     * @type {number}
     * @memberof IListAlertsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IListAlertsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<IAlertWithRoomInfo>}
     * @memberof IListAlertsResponse
     */
    'alerts'?: Array<IAlertWithRoomInfo>;
}
/**
 *
 * @export
 * @interface IListKeysResponse
 */
export interface IListKeysResponse {
    /**
     *
     * @type {number}
     * @memberof IListKeysResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IListKeysResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<IApiKey>}
     * @memberof IListKeysResponse
     */
    'keys'?: Array<IApiKey>;
}
/**
 *
 * @export
 * @interface IPipResponse
 */
export interface IPipResponse {
    /**
     *
     * @type {number}
     * @memberof IPipResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IPipResponse
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof IPipResponse
     */
    'image_url': string;
    /**
     *
     * @type {string}
     * @memberof IPipResponse
     */
    'label': string;
    /**
     *
     * @type {number}
     * @memberof IPipResponse
     */
    'value': number;
    /**
     *
     * @type {string}
     * @memberof IPipResponse
     */
    'unit': string;
}
/**
 *
 * @export
 * @interface IRateLimitInfo
 */
export interface IRateLimitInfo {
    /**
     *
     * @type {number}
     * @memberof IRateLimitInfo
     */
    'max': number;
    /**
     *
     * @type {number}
     * @memberof IRateLimitInfo
     */
    'remaining': number;
    /**
     *
     * @type {string}
     * @memberof IRateLimitInfo
     */
    'reset_at': string | null;
}
/**
 *
 * @export
 * @interface IRetrieveAgentHostsResponse
 */
export interface IRetrieveAgentHostsResponse {
    /**
     *
     * @type {number}
     * @memberof IRetrieveAgentHostsResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IRetrieveAgentHostsResponse
     */
    'message'?: string;
    /**
     *
     * @type {Array<PeerPresence>}
     * @memberof IRetrieveAgentHostsResponse
     */
    'agents': Array<PeerPresence>;
}
/**
 *
 * @export
 * @interface IRetrieveAggregateUsageResponse
 */
export interface IRetrieveAggregateUsageResponse {
    /**
     *
     * @type {number}
     * @memberof IRetrieveAggregateUsageResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IRetrieveAggregateUsageResponse
     */
    'message'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof IRetrieveAggregateUsageResponse
     */
    'usage'?: {
        [key: string]: {
            [key: string]: any;
        };
    };
}
/**
 *
 * @export
 * @interface IRetrieveAlertResponse
 */
export interface IRetrieveAlertResponse {
    /**
     *
     * @type {number}
     * @memberof IRetrieveAlertResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IRetrieveAlertResponse
     */
    'message'?: string;
    /**
     *
     * @type {IAlert}
     * @memberof IRetrieveAlertResponse
     */
    'alert'?: IAlert;
    /**
     *
     * @type {IRetrieveAlertResponseCreator}
     * @memberof IRetrieveAlertResponse
     */
    'creator'?: IRetrieveAlertResponseCreator;
    /**
     *
     * @type {TikTokLiveRoomInfo}
     * @memberof IRetrieveAlertResponse
     */
    'room_info'?: TikTokLiveRoomInfo;
}
/**
 *
 * @export
 * @interface IRetrieveAlertResponseCreator
 */
export interface IRetrieveAlertResponseCreator {
    /**
     *
     * @type {string}
     * @memberof IRetrieveAlertResponseCreator
     */
    'room_id': string | null;
    /**
     *
     * @type {string}
     * @memberof IRetrieveAlertResponseCreator
     */
    'state_label': string;
    /**
     *
     * @type {number}
     * @memberof IRetrieveAlertResponseCreator
     */
    'state': number;
    /**
     *
     * @type {string}
     * @memberof IRetrieveAlertResponseCreator
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface IRetrieveKeyResponse
 */
export interface IRetrieveKeyResponse {
    /**
     *
     * @type {number}
     * @memberof IRetrieveKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IRetrieveKeyResponse
     */
    'message'?: string;
    /**
     *
     * @type {IApiKey}
     * @memberof IRetrieveKeyResponse
     */
    'key'?: IApiKey;
}
/**
 *
 * @export
 * @interface IRetrievedCloudWebSocketsRouteResponse
 */
export interface IRetrievedCloudWebSocketsRouteResponse {
    /**
     *
     * @type {number}
     * @memberof IRetrievedCloudWebSocketsRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IRetrievedCloudWebSocketsRouteResponse
     */
    'message'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: WebSocketState; }}
     * @memberof IRetrievedCloudWebSocketsRouteResponse
     */
    'state'?: {
        [key: string]: WebSocketState;
    };
    /**
     *
     * @type {number}
     * @memberof IRetrievedCloudWebSocketsRouteResponse
     */
    'connections'?: number;
}
/**
 *
 * @export
 * @interface ISignLogPublic
 */
export interface ISignLogPublic {
    /**
     *
     * @type {number}
     * @memberof ISignLogPublic
     */
    'id': number;
    /**
     *
     * @type {string}
     * @memberof ISignLogPublic
     */
    'ts': string;
    /**
     *
     * @type {number}
     * @memberof ISignLogPublic
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ISignLogPublic
     */
    'client': string;
    /**
     *
     * @type {string}
     * @memberof ISignLogPublic
     */
    'ip': string;
    /**
     *
     * @type {number}
     * @memberof ISignLogPublic
     */
    'api_key_id': number;
    /**
     *
     * @type {string}
     * @memberof ISignLogPublic
     */
    'user_agent': string;
    /**
     *
     * @type {string}
     * @memberof ISignLogPublic
     */
    'agent_id': string;
}
/**
 *
 * @export
 * @interface ISignTikTokUrlBody
 */
export interface ISignTikTokUrlBody {
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'url': string;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'userAgent'?: string;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'method'?: ISignTikTokUrlBodyMethodEnum;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'sessionId'?: string;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'ttTargetIdc'?: string;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'payload'?: string;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'type'?: ISignTikTokUrlBodyTypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof ISignTikTokUrlBody
     */
    'includeBrowserParams'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ISignTikTokUrlBody
     */
    'includeVerifyFp'?: boolean;
}
export declare const ISignTikTokUrlBodyMethodEnum: {
    readonly Get: "GET";
    readonly Post: "POST";
    readonly Options: "OPTIONS";
    readonly Put: "PUT";
    readonly Delete: "DELETE";
    readonly Patch: "PATCH";
    readonly Head: "HEAD";
};
export type ISignTikTokUrlBodyMethodEnum = typeof ISignTikTokUrlBodyMethodEnum[keyof typeof ISignTikTokUrlBodyMethodEnum];
export declare const ISignTikTokUrlBodyTypeEnum: {
    readonly Fetch: "fetch";
    readonly Xhr: "xhr";
};
export type ISignTikTokUrlBodyTypeEnum = typeof ISignTikTokUrlBodyTypeEnum[keyof typeof ISignTikTokUrlBodyTypeEnum];
/**
 *
 * @export
 * @interface ISignTikTokUrlResponse
 */
export interface ISignTikTokUrlResponse {
    /**
     *
     * @type {number}
     * @memberof ISignTikTokUrlResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ISignTikTokUrlResponse
     */
    'message'?: string;
    /**
     *
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray}
     * @memberof ISignTikTokUrlResponse
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray;
}
/**
 *
 * @export
 * @interface ITestAlertTargetResponse
 */
export interface ITestAlertTargetResponse {
    /**
     *
     * @type {number}
     * @memberof ITestAlertTargetResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof ITestAlertTargetResponse
     */
    'message'?: string;
    /**
     *
     * @type {IAlertTargetStatus}
     * @memberof ITestAlertTargetResponse
     */
    'status'?: IAlertTargetStatus;
    /**
     *
     * @type {string}
     * @memberof ITestAlertTargetResponse
     */
    'statusLabel'?: string;
}
/**
 *
 * @export
 * @interface IUpdateKeyResponse
 */
export interface IUpdateKeyResponse {
    /**
     *
     * @type {number}
     * @memberof IUpdateKeyResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IUpdateKeyResponse
     */
    'message'?: string;
    /**
     *
     * @type {IApiKeyConfig}
     * @memberof IUpdateKeyResponse
     */
    'config'?: IApiKeyConfig;
}
/**
 *
 * @export
 * @interface IWebcastRoomChatPayload
 */
export interface IWebcastRoomChatPayload {
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'content': string;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'sessionId': string;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'ttTargetIdc': string;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'roomId': string;
}
/**
 *
 * @export
 * @interface IWebcastRoomChatRouteResponse
 */
export interface IWebcastRoomChatRouteResponse {
    /**
     *
     * @type {number}
     * @memberof IWebcastRoomChatRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomChatRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {any}
     * @memberof IWebcastRoomChatRouteResponse
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface IWebcastRoomIdRouteResponse
 */
export interface IWebcastRoomIdRouteResponse {
    /**
     *
     * @type {number}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'room_id'?: string;
    /**
     *
     * @type {boolean}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'is_live'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'ok': boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'routes_attempted': Array<string>;
}
/**
 *
 * @export
 * @interface IWebcastRoomInfoRouteResponse
 */
export interface IWebcastRoomInfoRouteResponse {
    /**
     *
     * @type {number}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'message'?: string;
    /**
     *
     * @type {TikTokLiveRoomInfo}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'data'?: TikTokLiveRoomInfo;
    /**
     *
     * @type {boolean}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'ok': boolean;
    /**
     *
     * @type {Array<ApiRoutes>}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'routes_attempted': Array<ApiRoutes>;
}
/**
 *
 * @export
 * @interface JWTConfig
 */
export interface JWTConfig {
    /**
     *
     * @type {string}
     * @memberof JWTConfig
     */
    'id': string;
    /**
     *
     * @type {number}
     * @memberof JWTConfig
     */
    'expiresAt': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfig
     */
    'ttl': number;
    /**
     *
     * @type {JWTConfigAccountData}
     * @memberof JWTConfig
     */
    'accountData': JWTConfigAccountData;
    /**
     *
     * @type {JWTConfigApiKeyData}
     * @memberof JWTConfig
     */
    'apiKeyData': JWTConfigApiKeyData;
    /**
     *
     * @type {WebSocketJWTLimits}
     * @memberof JWTConfig
     */
    'webSocketData': WebSocketJWTLimits;
    /**
     *
     * @type {string}
     * @memberof JWTConfig
     */
    'name': string | null;
}
/**
 *
 * @export
 * @interface JWTConfigAccountData
 */
export interface JWTConfigAccountData {
    /**
     *
     * @type {number}
     * @memberof JWTConfigAccountData
     */
    'day': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfigAccountData
     */
    'minute': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfigAccountData
     */
    'hour': number;
    /**
     *
     * @type {number}
     * @memberof JWTConfigAccountData
     */
    'id': number;
}
/**
 *
 * @export
 * @interface JWTConfigApiKeyData
 */
export interface JWTConfigApiKeyData {
    /**
     *
     * @type {number}
     * @memberof JWTConfigApiKeyData
     */
    'id': number;
}
/**
 *
 * @export
 * @interface JWTCreateConfig
 */
export interface JWTCreateConfig {
    /**
     *
     * @type {IAccountRequestLimits}
     * @memberof JWTCreateConfig
     */
    'limits'?: IAccountRequestLimits | null;
    /**
     *
     * @type {WebSocketJWTLimits}
     * @memberof JWTCreateConfig
     */
    'websockets'?: WebSocketJWTLimits | null;
    /**
     *
     * @type {number}
     * @memberof JWTCreateConfig
     */
    'expireAfter': number;
    /**
     *
     * @type {string}
     * @memberof JWTCreateConfig
     */
    'name'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const LiveClient: {
    readonly TtliveJava: "ttlive-java";
    readonly TtliveNode: "ttlive-node";
    readonly TtlivePython: "ttlive-python";
    readonly TtliveNet: "ttlive-net";
    readonly TtliveRust: "ttlive-rust";
    readonly GotiktokLive: "gotiktok_live";
    readonly TtliveCloudflare: "ttlive-cloudflare";
    readonly TtliveOther: "ttlive-other";
};
export type LiveClient = typeof LiveClient[keyof typeof LiveClient];
/**
 *
 * @export
 * @enum {number}
 */
export declare const LogRequestMethod: {
    readonly NUMBER_0: 0;
    readonly NUMBER_1: 1;
};
export type LogRequestMethod = typeof LogRequestMethod[keyof typeof LogRequestMethod];
/**
 * Make all properties in T optional
 * @export
 * @interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
 */
export interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber {
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'avatar_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'nickname'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'sec_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'numeric_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'signature'?: string;
    /**
     *
     * @type {boolean}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'is_verified'?: boolean;
    /**
     *
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'following'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'followers'?: number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
 */
export interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray {
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'signedUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'userAgent'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'browserName'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'browserVersion'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'tokens'?: {
        [key: string]: string;
    };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'requestHeaders'?: {
        [key: string]: string;
    };
    /**
     *
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'cookies'?: Array<{
        [key: string]: any;
    }>;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
 */
export interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString {
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'status'?: number;
    /**
     *
     * @type {boolean}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'is_live'?: boolean;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'cover_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'title'?: string;
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'start_time'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'current_viewers'?: number;
    /**
     *
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'total_viewers'?: number;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'hls_pull_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'hls_pull_url_ld'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'flv_pull_url'?: string;
    /**
     *
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'flv_pull_url_ld'?: string;
}
/**
 *
 * @export
 * @interface PeerPresence
 */
export interface PeerPresence {
    /**
     *
     * @type {number}
     * @memberof PeerPresence
     */
    'lastSeen': number;
    /**
     *
     * @type {PeerRole}
     * @memberof PeerPresence
     */
    'role': PeerRole;
    /**
     *
     * @type {string}
     * @memberof PeerPresence
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof PeerPresence
     */
    'type': PeerPresenceTypeEnum;
}
export declare const PeerPresenceTypeEnum: {
    readonly Api: "api";
    readonly Agent: "agent";
};
export type PeerPresenceTypeEnum = typeof PeerPresenceTypeEnum[keyof typeof PeerPresenceTypeEnum];
/**
 *
 * @export
 * @enum {string}
 */
export declare const PeerRole: {
    readonly Public: "public";
    readonly Enterprise: "enterprise";
    readonly Staging: "staging";
};
export type PeerRole = typeof PeerRole[keyof typeof PeerRole];
/**
 *
 * @export
 * @interface Pips200Response
 */
export interface Pips200Response {
    /**
     *
     * @type {number}
     * @memberof Pips200Response
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof Pips200Response
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof Pips200Response
     */
    'image_url': string;
    /**
     *
     * @type {string}
     * @memberof Pips200Response
     */
    'label': string;
    /**
     *
     * @type {number}
     * @memberof Pips200Response
     */
    'value': number;
    /**
     *
     * @type {string}
     * @memberof Pips200Response
     */
    'unit': string;
}
/**
 *
 * @export
 * @interface SignWebcastUrl200Response
 */
export interface SignWebcastUrl200Response {
    /**
     *
     * @type {number}
     * @memberof SignWebcastUrl200Response
     */
    'code': number;
    /**
     *
     * @type {string}
     * @memberof SignWebcastUrl200Response
     */
    'message'?: string;
    /**
     *
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray}
     * @memberof SignWebcastUrl200Response
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const StreamType: {
    readonly HlsLd: "hls_ld";
    readonly HlsSd: "hls_sd";
    readonly FlvLd: "flv_ld";
    readonly FlvSd: "flv_sd";
};
export type StreamType = typeof StreamType[keyof typeof StreamType];
/**
 *
 * @export
 * @interface TikTokLiveRoomInfo
 */
export interface TikTokLiveRoomInfo {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof TikTokLiveRoomInfo
     */
    'raw': {
        [key: string]: any;
    };
    /**
     *
     * @type {PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString}
     * @memberof TikTokLiveRoomInfo
     */
    'room_info'?: PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString;
    /**
     *
     * @type {TikTokLiveRoomInfoUser}
     * @memberof TikTokLiveRoomInfo
     */
    'user'?: TikTokLiveRoomInfoUser;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfo
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface TikTokLiveRoomInfoUser
 */
export interface TikTokLiveRoomInfoUser {
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfoUser
     */
    'avatar_url'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfoUser
     */
    'nickname'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfoUser
     */
    'sec_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfoUser
     */
    'numeric_uid'?: string;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfoUser
     */
    'signature'?: string;
    /**
     *
     * @type {boolean}
     * @memberof TikTokLiveRoomInfoUser
     */
    'is_verified'?: boolean;
    /**
     *
     * @type {number}
     * @memberof TikTokLiveRoomInfoUser
     */
    'following'?: number;
    /**
     *
     * @type {number}
     * @memberof TikTokLiveRoomInfoUser
     */
    'followers'?: number;
    /**
     *
     * @type {string}
     * @memberof TikTokLiveRoomInfoUser
     */
    'unique_id': string;
}
/**
 *
 * @export
 * @interface WebSocketJWTLimits
 */
export interface WebSocketJWTLimits {
    /**
     *
     * @type {Array<string>}
     * @memberof WebSocketJWTLimits
     */
    'allowedCreators': Array<string> | null;
    /**
     *
     * @type {number}
     * @memberof WebSocketJWTLimits
     */
    'maxWebSockets': number;
}
/**
 *
 * @export
 * @interface WebSocketState
 */
export interface WebSocketState {
    /**
     *
     * @type {number}
     * @memberof WebSocketState
     */
    'apiKeyId': number;
    /**
     *
     * @type {string}
     * @memberof WebSocketState
     */
    'jwtName': string | null;
    /**
     *
     * @type {string}
     * @memberof WebSocketState
     */
    'jwtId': string | null;
    /**
     *
     * @type {number}
     * @memberof WebSocketState
     */
    'heartbeat': number;
    /**
     *
     * @type {string}
     * @memberof WebSocketState
     */
    'wsId': string;
}
/**
 * AccountsApi - axios parameter creator
 * @export
 */
export declare const AccountsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countSignUsage: (accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignUsage: (accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAggregateUsage: (accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
export declare const AccountsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICountSignUsage>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGetSignUsageResponse>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveAggregateUsageResponse>>;
};
/**
 * AccountsApi - factory interface
 * @export
 */
export declare const AccountsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<ICountSignUsage>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<IGetSignUsageResponse>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveAggregateUsageResponse>;
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export declare class AccountsApi extends BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ICountSignUsage, any>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IGetSignUsageResponse, any>>;
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IRetrieveAggregateUsageResponse, any>>;
}
/**
 * @export
 */
export declare const RetrieveAggregateUsagePeriodEnum: {
    readonly Hour: "hour";
    readonly Day: "day";
};
export type RetrieveAggregateUsagePeriodEnum = typeof RetrieveAggregateUsagePeriodEnum[keyof typeof RetrieveAggregateUsagePeriodEnum];
/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
export declare const AlertTargetsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertTarget: (accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlertTarget: (accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlertTargets: (accountId: number, alertId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testAlertTarget: (accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
export declare const AlertTargetsApiFp: (configuration?: Configuration) => {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertTarget(accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateAlertTargetResponse>>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDeleteAlertTargetResponse>>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IListAlertTargetsResponse>>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITestAlertTargetResponse>>;
};
/**
 * AlertTargetsApi - factory interface
 * @export
 */
export declare const AlertTargetsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertTarget(accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<ICreateAlertTargetResponse>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<IDeleteAlertTargetResponse>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<IListAlertTargetsResponse>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<ITestAlertTargetResponse>;
};
/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
export declare class AlertTargetsApi extends BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    createAlertTarget(accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ICreateAlertTargetResponse, any>>;
    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IDeleteAlertTargetResponse, any>>;
    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IListAlertTargetsResponse, any>>;
    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ITestAlertTargetResponse, any>>;
}
/**
 * AlertsApi - axios parameter creator
 * @export
 */
export declare const AlertsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a creator alert. These alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlert: (accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlert: (accountId: number, alertId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {number} accountId
     * @param {boolean} [includeRoomInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlerts: (accountId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {boolean} [includeRoomInfo] Whether to include room information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAlert: (accountId: number, alertId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AlertsApi - functional programming interface
 * @export
 */
export declare const AlertsApiFp: (configuration?: Configuration) => {
    /**
     * Create a creator alert. These alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlert(accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateAlertResponse>>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDeleteAlertResponse>>;
    /**
     *
     * @param {number} accountId
     * @param {boolean} [includeRoomInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlerts(accountId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IListAlertsResponse>>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {boolean} [includeRoomInfo] Whether to include room information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAlert(accountId: number, alertId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveAlertResponse>>;
};
/**
 * AlertsApi - factory interface
 * @export
 */
export declare const AlertsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a creator alert. These alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlert(accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<ICreateAlertResponse>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<IDeleteAlertResponse>;
    /**
     *
     * @param {number} accountId
     * @param {boolean} [includeRoomInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAlerts(accountId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<IListAlertsResponse>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {boolean} [includeRoomInfo] Whether to include room information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveAlert(accountId: number, alertId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveAlertResponse>;
};
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export declare class AlertsApi extends BaseAPI {
    /**
     * Create a creator alert. These alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    createAlert(accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ICreateAlertResponse, any>>;
    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IDeleteAlertResponse, any>>;
    /**
     *
     * @param {number} accountId
     * @param {boolean} [includeRoomInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    listAlerts(accountId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IListAlertsResponse, any>>;
    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {boolean} [includeRoomInfo] Whether to include room information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    retrieveAlert(accountId: number, alertId: number, includeRoomInfo?: boolean, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IRetrieveAlertResponse, any>>;
}
/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export declare const AnalyticsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAgents: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHosts: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve stats as an SVG
     * @param {LogRequestMethod} statName Name of the stat to retrieve
     * @param {string} [labelColour] Specify label colour in SVG
     * @param {string} [valueColour] Specify value colour in SVG
     * @param {number} [hours] The number of hours to retrieve the stat for
     * @param {LiveClient} [client] The client to filter for
     * @param {boolean} [json] Add the ability to retrieve the pip as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pips: (statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export declare const AnalyticsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveAgentHostsResponse>>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IHostsResponse>>;
    /**
     * Retrieve stats as an SVG
     * @param {LogRequestMethod} statName Name of the stat to retrieve
     * @param {string} [labelColour] Specify label colour in SVG
     * @param {string} [valueColour] Specify value colour in SVG
     * @param {number} [hours] The number of hours to retrieve the stat for
     * @param {LiveClient} [client] The client to filter for
     * @param {boolean} [json] Add the ability to retrieve the pip as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pips(statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pips200Response>>;
};
/**
 * AnalyticsApi - factory interface
 * @export
 */
export declare const AnalyticsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAgents(options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveAgentHostsResponse>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHosts(options?: RawAxiosRequestConfig): AxiosPromise<IHostsResponse>;
    /**
     * Retrieve stats as an SVG
     * @param {LogRequestMethod} statName Name of the stat to retrieve
     * @param {string} [labelColour] Specify label colour in SVG
     * @param {string} [valueColour] Specify value colour in SVG
     * @param {number} [hours] The number of hours to retrieve the stat for
     * @param {LiveClient} [client] The client to filter for
     * @param {boolean} [json] Add the ability to retrieve the pip as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pips(statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Pips200Response>;
};
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export declare class AnalyticsApi extends BaseAPI {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    fetchAgents(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IRetrieveAgentHostsResponse, any>>;
    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getHosts(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IHostsResponse, any>>;
    /**
     * Retrieve stats as an SVG
     * @param {LogRequestMethod} statName Name of the stat to retrieve
     * @param {string} [labelColour] Specify label colour in SVG
     * @param {string} [valueColour] Specify value colour in SVG
     * @param {number} [hours] The number of hours to retrieve the stat for
     * @param {LiveClient} [client] The client to filter for
     * @param {boolean} [json] Add the ability to retrieve the pip as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    pips(statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<Pips200Response, any>>;
}
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export declare const AuthenticationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJWT: (accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey: (accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKey: (accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey: (accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeys: (accountId: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKey: (accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export declare const AuthenticationApiFp: (configuration?: Configuration) => {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateJWTResponse>>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey(accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateKeyResponse>>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDeleteKeyResponse>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveKeyResponse>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IListKeysResponse>>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IUpdateKeyResponse>>;
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
export declare const AuthenticationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): AxiosPromise<ICreateJWTResponse>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey(accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<ICreateKeyResponse>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): AxiosPromise<IDeleteKeyResponse>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveKeyResponse>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listKeys(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<IListKeysResponse>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<IUpdateKeyResponse>;
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export declare class AuthenticationApi extends BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ICreateJWTResponse, any>>;
    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    createKey(accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<ICreateKeyResponse, any>>;
    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IDeleteKeyResponse, any>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IRetrieveKeyResponse, any>>;
    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IListKeysResponse, any>>;
    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IUpdateKeyResponse, any>>;
}
/**
 * @export
 */
export declare const DeleteKeyDeleteByEnum: {
    readonly Value: "value";
    readonly Name: "name";
    readonly Id: "id";
};
export type DeleteKeyDeleteByEnum = typeof DeleteKeyDeleteByEnum[keyof typeof DeleteKeyDeleteByEnum];
/**
 * @export
 */
export declare const GetKeyRetrieveByEnum: {
    readonly Value: "value";
    readonly Name: "name";
    readonly Id: "id";
};
export type GetKeyRetrieveByEnum = typeof GetKeyRetrieveByEnum[keyof typeof GetKeyRetrieveByEnum];
/**
 * @export
 */
export declare const UpdateKeyUpdateByEnum: {
    readonly Value: "value";
    readonly Name: "name";
    readonly Id: "id";
};
export type UpdateKeyUpdateByEnum = typeof UpdateKeyUpdateByEnum[keyof typeof UpdateKeyUpdateByEnum];
/**
 * WebcastApi - axios parameter creator
 * @export
 */
export declare const WebcastApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
     * @param {string} client The client ID
     * @param {string} [roomId] The room ID to fetch the webcast URL for
     * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
     * @param {string} [cursor] The cursor to fetch the webcast URL for
     * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
     * @param {string} [userAgent] Override the user agent used in the signature
     * @param {string} [ttTargetIdc] The target IDC to use for the request
     * @param {boolean} [clientEnter] Whether the client is entering the room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWebcastURL: (client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the currently connected WebSocket clients for your account. Only for paid plans.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectedWebSockets: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRateLimits: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomCover: (uniqueId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch Room Id for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomId: (uniqueId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {boolean} [giftInfo] Optional flag to include gift information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomInfo: (uniqueId: string, giftInfo?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomVideo: (uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Send a chat to a TikTok LIVE room.
     * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRoomChat: (iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signWebcastUrl: (iSignTikTokUrlBody: ISignTikTokUrlBody, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WebcastApi - functional programming interface
 * @export
 */
export declare const WebcastApiFp: (configuration?: Configuration) => {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
     * @param {string} client The client ID
     * @param {string} [roomId] The room ID to fetch the webcast URL for
     * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
     * @param {string} [cursor] The cursor to fetch the webcast URL for
     * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
     * @param {string} [userAgent] Override the user agent used in the signature
     * @param {string} [ttTargetIdc] The target IDC to use for the request
     * @param {boolean} [clientEnter] Whether the client is entering the room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWebcastURL(client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Retrieve the currently connected WebSocket clients for your account. Only for paid plans.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectedWebSockets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrievedCloudWebSocketsRouteResponse>>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRateLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGetRateLimits>>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IJSONResponse>>;
    /**
     * Fetch Room Id for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IWebcastRoomIdRouteResponse>>;
    /**
     * Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {boolean} [giftInfo] Optional flag to include gift information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomInfo(uniqueId: string, giftInfo?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IWebcastRoomInfoRouteResponse>>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IJSONResponse>>;
    /**
     * Send a chat to a TikTok LIVE room.
     * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRoomChat(iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IWebcastRoomChatRouteResponse>>;
    /**
     *
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signWebcastUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignWebcastUrl200Response>>;
};
/**
 * WebcastApi - factory interface
 * @export
 */
export declare const WebcastApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
     * @param {string} client The client ID
     * @param {string} [roomId] The room ID to fetch the webcast URL for
     * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
     * @param {string} [cursor] The cursor to fetch the webcast URL for
     * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
     * @param {string} [userAgent] Override the user agent used in the signature
     * @param {string} [ttTargetIdc] The target IDC to use for the request
     * @param {boolean} [clientEnter] Whether the client is entering the room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWebcastURL(client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<object>;
    /**
     * Retrieve the currently connected WebSocket clients for your account. Only for paid plans.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectedWebSockets(options?: RawAxiosRequestConfig): AxiosPromise<IRetrievedCloudWebSocketsRouteResponse>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRateLimits(options?: RawAxiosRequestConfig): AxiosPromise<IGetRateLimits>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<IJSONResponse>;
    /**
     * Fetch Room Id for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<IWebcastRoomIdRouteResponse>;
    /**
     * Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {boolean} [giftInfo] Optional flag to include gift information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomInfo(uniqueId: string, giftInfo?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<IWebcastRoomInfoRouteResponse>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): AxiosPromise<IJSONResponse>;
    /**
     * Send a chat to a TikTok LIVE room.
     * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRoomChat(iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig): AxiosPromise<IWebcastRoomChatRouteResponse>;
    /**
     *
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signWebcastUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, options?: RawAxiosRequestConfig): AxiosPromise<SignWebcastUrl200Response>;
};
/**
 * WebcastApi - object-oriented interface
 * @export
 * @class WebcastApi
 * @extends {BaseAPI}
 */
export declare class WebcastApi extends BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
     * @param {string} client The client ID
     * @param {string} [roomId] The room ID to fetch the webcast URL for
     * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
     * @param {string} [cursor] The cursor to fetch the webcast URL for
     * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
     * @param {string} [userAgent] Override the user agent used in the signature
     * @param {string} [ttTargetIdc] The target IDC to use for the request
     * @param {boolean} [clientEnter] Whether the client is entering the room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    fetchWebcastURL(client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<object, any>>;
    /**
     * Retrieve the currently connected WebSocket clients for your account. Only for paid plans.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    getConnectedWebSockets(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IRetrievedCloudWebSocketsRouteResponse, any>>;
    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    getRateLimits(options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IGetRateLimits, any>>;
    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IJSONResponse, any>>;
    /**
     * Fetch Room Id for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IWebcastRoomIdRouteResponse, any>>;
    /**
     * Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {boolean} [giftInfo] Optional flag to include gift information in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    retrieveRoomInfo(uniqueId: string, giftInfo?: boolean, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IWebcastRoomInfoRouteResponse, any>>;
    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IJSONResponse, any>>;
    /**
     * Send a chat to a TikTok LIVE room.
     * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    sendRoomChat(iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<IWebcastRoomChatRouteResponse, any>>;
    /**
     *
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    signWebcastUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, options?: RawAxiosRequestConfig): Promise<globalAxios.AxiosResponse<SignWebcastUrl200Response, any>>;
}
//# sourceMappingURL=api.d.ts.map