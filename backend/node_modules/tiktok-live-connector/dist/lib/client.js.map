{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/lib/client.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    AlreadyConnectedError,\n    AlreadyConnectingError,\n    FetchIsLiveError,\n    InvalidResponseError,\n    UserOfflineError\n} from '@/types/errors';\n\nimport TypedEventEmitter from 'typed-emitter';\nimport { EventEmitter } from 'node:events';\nimport TikTokWsClient from '@/lib/ws/lib/ws-client';\nimport Config from '@/lib/config';\nimport {\n    DecodedData,\n    DecodedWebcastPushFrame,\n    RoomGiftInfo,\n    RoomInfo,\n    TikTokLiveConnectionOptions,\n    WebSocketParams\n} from '@/types/client';\nimport { validateAndNormalizeUniqueId } from '@/lib/utilities';\nimport { RoomInfoResponse, TikTokWebClient } from '@/lib/web';\nimport { EulerSigner } from '@/lib/web/lib/tiktok-signer';\nimport {\n    ClientEventMap,\n    ConnectState,\n    ControlEvent,\n    TikTokLiveConnectionState,\n    WebcastEvent,\n    WebcastEventMap\n} from '@/types/events';\nimport { IWebcastRoomChatPayload, IWebcastRoomChatRouteResponse } from '@eulerstream/euler-api-sdk';\nimport { ControlAction, ProtoMessageFetchResult } from '@/types';\n\n\nexport class TikTokLiveConnection extends (EventEmitter as new () => TypedEventEmitter<ClientEventMap>) {\n\n    // Public properties\n    public webClient: TikTokWebClient;\n    public wsClient: TikTokWsClient | null = null;\n\n    // Protected properties\n    protected _roomInfo: RoomInfo | null = null;\n    protected _availableGifts: Record<any, any> | null = null;\n    protected _connectState: ConnectState = ConnectState.DISCONNECTED;\n    public readonly options: TikTokLiveConnectionOptions;\n\n    /**\n     * Create a new TikTokLiveConnection instance\n     * @param {string} uniqueId TikTok username (from URL)\n     * @param {object} [options] Connection options\n     * @param {boolean} [options[].authenticateWs=false] Authenticate the WebSocket connection using the session ID from the \"sessionid\" cookie\n     * @param {boolean} [options[].processInitialData=true] Process the initital data which includes messages of the last minutes\n     * @param {boolean} [options[].fetchRoomInfoOnConnect=false] Fetch the room info (room status, streamer info, etc.) on connect (will be returned when calling connect())\n     * @param {boolean} [options[].enableExtendedGiftInfo=false] Enable this option to get extended information on 'gift' events like gift name and cost\n     * @param {boolean} [options[].enableRequestPolling=true] Use request polling if no WebSocket upgrade is offered. If `false` an exception will be thrown if TikTok does not offer a WebSocket upgrade.\n     * @param {number} [options[].requestPollingIntervalMs=1000] Request polling interval if WebSocket is not used\n     * @param {string} [options[].sessionId=null] The session ID from the \"sessionid\" cookie is required if you want to send automated messages in the chat.\n     * @param {object} [options[].webClientParams={}] Custom client params for Webcast API\n     * @param {object} [options[].webClientHeaders={}] Custom request headers for axios\n     * @param {object} [options[].websocketHeaders={}] Custom request headers for websocket.client\n     * @param {object} [options[].webClientOptions={}] Custom request options for axios. Here you can specify an `httpsAgent` to use a proxy and a `timeout` value for example.\n     * @param {object} [options[].websocketOptions={}] Custom request options for websocket.client. Here you can specify an `agent` to use a proxy and a `timeout` value for example.\n     * @param {boolean} [options[].connectWithUniqueId=false] Connect to the live stream using the unique ID instead of the room ID. If `true`, the room ID will be fetched from the TikTok API.\n     * @param {boolean} [options[].logFetchFallbackErrors=false] Log errors when falling back to the API or Euler source\n     * @param {function} [options[].signedWebSocketProvider] Custom function to fetch the signed WebSocket URL. If not specified, the default function will be used.\n     * @param {EulerSigner} [signer] TikTok Signer instance. If not provided, a new instance will be created using the provided options\n     */\n    constructor(\n        public readonly uniqueId: string,\n        options?: Partial<TikTokLiveConnectionOptions>,\n        public readonly signer?: EulerSigner\n    ) {\n        super();\n        this.uniqueId = validateAndNormalizeUniqueId(uniqueId);\n\n        // Assign the options\n        this.options = {\n            connectWithUniqueId: false,\n            processInitialData: true,\n            fetchRoomInfoOnConnect: true,\n            enableExtendedGiftInfo: false,\n            enableRequestPolling: true,\n            requestPollingIntervalMs: 1000,\n            sessionId: null,\n            ttTargetIdc: null,\n            signApiKey: null,\n            disableEulerFallbacks: false,\n\n            // Override Http client params\n            webClientParams: {},\n            webClientHeaders: {},\n            webClientOptions: {},\n\n            // Override WebSocket params\n            wsClientHeaders: {},\n            wsClientOptions: {},\n            wsClientParams: {},\n\n            authenticateWs: false,\n            signedWebSocketProvider: undefined,\n            ...options\n        };\n\n        this.webClient = new TikTokWebClient(\n            {\n                customHeaders: this.options?.webClientHeaders || {},\n                axiosOptions: this.options?.webClientOptions,\n                clientParams: this.options?.webClientParams || {},\n                authenticateWs: this.options?.authenticateWs || false,\n                signApiKey: this.options?.signApiKey ?? undefined\n            },\n            signer\n        );\n\n        this.webClient.cookieJar.setSession(this.options.sessionId, this.options.ttTargetIdc);\n        this.setDisconnected();\n    }\n\n    /**\n     * Set the connection state to disconnected\n     * @protected\n     */\n    protected setDisconnected() {\n        this._connectState = ConnectState.DISCONNECTED;\n        this._roomInfo = null;\n\n        // Reset the client parameters\n        this.clientParams.cursor = '';\n        this.clientParams.room_id = '';\n        this.clientParams.internal_ext = '';\n    }\n\n    /**\n     * Get the current Room Info\n     */\n    public get roomInfo(): RoomInfoResponse {\n        return this._roomInfo;\n    }\n\n    /**\n     * Get the available gifts\n     */\n    public get availableGifts() {\n        return this._availableGifts;\n    }\n\n    /**\n     * Get the current connection state\n     */\n    public get isConnecting() {\n        return this._connectState === ConnectState.CONNECTING;\n    }\n\n    /**\n     * Check if the connection is established\n     */\n    public get isConnected() {\n        return this._connectState === ConnectState.CONNECTED;\n    }\n\n    /**\n     * Get the current client parameters\n     */\n    public get clientParams() {\n        return this.webClient.clientParams;\n    }\n\n    /**\n     * Get the current room ID\n     */\n    public get roomId(): string {\n        return this.webClient.roomId;\n    }\n\n\n    /**\n     * Get the current connection state including the cached room info and all available gifts\n     * (if `enableExtendedGiftInfo` option enabled)\n     */\n    public get state(): TikTokLiveConnectionState {\n        return {\n            isConnected: this.isConnected,\n            roomId: this.roomId,\n            roomInfo: this.roomInfo,\n            availableGifts: this.availableGifts\n        };\n    }\n\n    /**\n     * Connects to the live stream of the specified streamer\n     * @param roomId Room ID to connect to. If not specified, the room ID will be retrieved from the TikTok API\n     * @returns The current connection state\n     */\n    async connect(roomId?: string): Promise<TikTokLiveConnectionState> {\n\n        switch (this._connectState) {\n            case ConnectState.CONNECTED:\n                throw new AlreadyConnectedError('Already connected!');\n\n            case ConnectState.CONNECTING:\n                throw new AlreadyConnectingError('Already connecting!');\n\n            default:\n            case ConnectState.DISCONNECTED:\n                try {\n                    this._connectState = ConnectState.CONNECTING;\n                    await this._connect(roomId);\n                    this._connectState = ConnectState.CONNECTED;\n                    this.emit(ControlEvent.CONNECTED, this.state);\n                    return this.state;\n                } catch (err) {\n                    this._connectState = ConnectState.DISCONNECTED;\n                    this.handleError(err, 'Error while connecting');\n                    throw err;\n                }\n        }\n    }\n\n    /**\n     * Connects to the live stream of the specified streamer\n     *\n     * @param roomId Room ID to connect to. If not specified, the room ID will be retrieved from the TikTok API\n     * @protected\n     */\n    protected async _connect(roomId?: string): Promise<void> {\n\n        // First we set the Room ID\n        if (!this.options.connectWithUniqueId || this.options.fetchRoomInfoOnConnect || this.options.enableExtendedGiftInfo) {\n            this.clientParams.room_id = roomId || this.clientParams.room_id || await this.fetchRoomId();\n        }\n\n        // <Optional> Fetch Room Info\n        if (this.options?.fetchRoomInfoOnConnect) {\n            this._roomInfo = await this.fetchRoomInfo();\n            if (this._roomInfo.data.status === 4) {\n                throw new UserOfflineError('The requested user isn\\'t online :(');\n            }\n        }\n\n        // <Optional> Fetch Gift Info\n        if (this.options?.enableExtendedGiftInfo) {\n            this._availableGifts = await this.fetchAvailableGifts();\n        }\n\n        // <Required> Fetch initial room info. Let the user specify their own backend for signing, if they don't want to use Euler\n        const protoMessageFetchResult: ProtoMessageFetchResult = await (this.options.signedWebSocketProvider || this.webClient.fetchSignedWebSocketFromEuler)(\n            {\n                roomId: (roomId || !this.options.connectWithUniqueId) ? this.roomId : undefined,\n                uniqueId: this.options.connectWithUniqueId ? this.uniqueId : undefined,\n                sessionId: this.options.authenticateWs ? this.options.sessionId : undefined\n            }\n        );\n\n        // <Optional> Process the initial data\n        if (this.options?.processInitialData) {\n            await this.processProtoMessageFetchResult(protoMessageFetchResult);\n        }\n\n        // If we didn't receive a cursor\n        if (!protoMessageFetchResult.cursor) {\n            throw new InvalidResponseError('Missing cursor in initial fetch response.');\n        }\n\n        // Update client parameters\n        this.clientParams.cursor = protoMessageFetchResult.cursor;\n        this.clientParams.internal_ext = protoMessageFetchResult.internalExt;\n\n        // Connect to the WebSocket\n        const wsParams: WebSocketParams = {\n            compress: 'gzip',\n            room_id: this.roomId,\n            internal_ext: protoMessageFetchResult.internalExt,\n            cursor: protoMessageFetchResult.cursor,\n            ...protoMessageFetchResult.wsParams\n        };\n\n        this.wsClient = await this.setupWebsocket(protoMessageFetchResult.wsUrl, wsParams);\n\n        // Default app behaviour is to send the im_enter_room message on WebSocket connect\n        this.wsClient.switchRooms(this.roomId);\n\n        this.emit(ControlEvent.WEBSOCKET_CONNECTED, this.wsClient);\n\n    }\n\n    /**\n     * Disconnects the connection to the live stream\n     */\n    async disconnect(): Promise<void> {\n        if (this.isConnected) {\n            await this.wsClient?.close();\n        }\n    }\n\n    /**\n     * Fetch the room ID from the TikTok API\n     * @param uniqueId Optional unique ID to use instead of the current one\n     */\n    public async fetchRoomId(uniqueId?: string): Promise<string> {\n        let errors: any[] = [];\n        uniqueId ||= this.uniqueId;\n\n        // Method 1\n        try {\n            const roomInfo = await this.webClient.fetchRoomInfoFromHtml({ uniqueId: uniqueId });\n            const roomId = roomInfo.liveRoomUserInfo.liveRoom.roomId;\n            if (!roomId) throw new Error('Failed to extract Room ID from HTML.');\n            return roomId;\n        } catch (ex) {\n            this.handleError(ex, 'Failed to retrieve Room ID from main page, falling back to API source...');\n            errors.push(ex);\n        }\n\n        // Method 2 (API Fallback)\n        try {\n            const roomData = await this.webClient.fetchRoomInfoFromApiLive({ uniqueId: uniqueId });\n            const roomId = roomData?.data?.user?.roomId;\n            if (!roomId) throw new Error('Failed to extract Room ID from API.');\n            return roomId;\n        } catch (ex) {\n            this.handleError(ex, 'Failed to retrieve Room ID from API source, falling back to Euler source...');\n            errors.push(ex);\n        }\n\n        // Method 3 (Euler Fallback)\n        if (!this.options.disableEulerFallbacks) {\n            try {\n                const response = await this.webClient.fetchRoomIdFromEuler({ uniqueId: uniqueId });\n                if (!response.ok) throw new Error(`Failed to retrieve Room ID from Euler due to an error: ${response.message}`);\n                if (!response.room_id) throw new Error('Failed to extract Room ID from Euler.');\n                return response.room_id;\n            } catch (err) {\n                this.handleError(err, 'Failed to retrieve Room ID from Euler source, no more sources available...');\n                errors.push(err);\n            }\n        }\n\n        // If we reach this point, it means all sources have failed\n        const errMsg: string = 'Failed to retrieve Room ID from all sources.';\n        const failErr = new FetchIsLiveError(errors, errMsg);\n        this.handleError(failErr, errMsg);\n        throw failErr;\n    }\n\n    public async fetchIsLive(): Promise<boolean> {\n        const errors: any[] = [];\n        const isOnline = (status: number) => status !== 4;\n\n        // Method 1 (HTML)\n        try {\n            const roomInfo = await this.webClient.fetchRoomInfoFromHtml({ uniqueId: this.uniqueId });\n            if (roomInfo?.liveRoomUserInfo?.liveRoom?.status === undefined) throw new Error('Failed to extract status from HTML.');\n            return isOnline(roomInfo?.liveRoomUserInfo?.liveRoom?.status);\n        } catch (ex) {\n            this.handleError(ex, 'Failed to retrieve room info for live status from main page, falling back to API source...');\n            errors.push(ex);\n        }\n\n        // Method 2 (API)\n        try {\n            const roomData = await this.webClient.fetchRoomInfoFromApiLive({ uniqueId: this.uniqueId });\n            if (roomData?.data?.liveRoom?.status === undefined) throw new Error('Failed to extract status from API.');\n            return isOnline(roomData?.data?.liveRoom?.status);\n        } catch (err) {\n            this.handleError(err, 'Failed to retrieve room info for live status from API source, falling back to Euler source...');\n            errors.push(err);\n        }\n\n        // Method 3 (Euler)\n        if (!this.options.disableEulerFallbacks) {\n            try {\n                const roomData = await this.webClient.fetchRoomIdFromEuler({ uniqueId: this.uniqueId });\n                if (roomData.code !== 200) throw new Error('Failed to extract status from Euler.');\n                return roomData.is_live;\n            } catch (err) {\n                this.handleError(err, 'Failed to retrieve room info for live status from Euler source, no more sources available...');\n                errors.push(err);\n            }\n        }\n\n        // If we reach this point, it means all sources have failed\n        const errMsg: string = 'Failed to retrieve live status rom all sources.';\n        const failErr = new FetchIsLiveError(errors, errMsg);\n        this.handleError(failErr, errMsg);\n        throw failErr;\n\n    }\n\n    /**\n     * Wait until the streamer is live\n     * @param seconds Number of seconds to wait before checking if the streamer is live again\n     */\n    public async waitUntilLive(seconds: number = 60): Promise<void> {\n        seconds = Math.max(30, seconds);\n\n        return new Promise(async (resolve) => {\n            const fetchIsLive = async () => {\n                const isLive = await this.fetchIsLive();\n\n                if (isLive) {\n                    clearInterval(interval);\n                    resolve();\n                }\n            };\n\n            const interval = setInterval(async () => fetchIsLive(), seconds * 1000);\n            await fetchIsLive();\n        });\n\n    }\n\n    /**\n     * Get the current room info (including streamer info, room status and statistics)\n     * @returns Promise that will be resolved when the room info has been retrieved from the API\n     */\n    public async fetchRoomInfo(): Promise<RoomInfoResponse> {\n        if (!this.webClient.roomId) await this.fetchRoomId();\n        this._roomInfo = await this.webClient.fetchRoomInfo();\n        return this._roomInfo;\n    }\n\n    /**\n     * Get the available gifts in the current room\n     * @returns Promise that will be resolved when the available gifts have been retrieved from the API\n     */\n    public async fetchAvailableGifts(): Promise<RoomGiftInfo> {\n        try {\n            let response = await this.webClient.getJsonObjectFromWebcastApi('gift/list/', this.clientParams);\n            return response.data.gifts;\n        } catch (err) {\n            throw new InvalidResponseError(`Failed to fetch available gifts. ${err.message}`, err);\n        }\n    }\n\n    /**\n     * Send a message to a TikTok LIVE Room\n     *\n     * @param content Message content to send to the stream\n     * @param options Optional parameters for the message (incl. parameter overrides)\n     */\n    public async sendMessage(content: string, options?: Partial<Omit<IWebcastRoomChatPayload, 'content'>>): Promise<IWebcastRoomChatRouteResponse> {\n\n        const roomId = options?.roomId || this.roomId;\n        if (!roomId) {\n            throw new Error('Room ID is required to send a message.');\n        }\n\n        const sessionId = options?.sessionId || this.webClient.cookieJar.sessionId;\n        if (!sessionId) {\n            throw new Error('Session ID is required to send a message.');\n        }\n\n        const ttTargetIdc = options?.ttTargetIdc || this.webClient.cookieJar.ttTargetIdc;\n        if (!ttTargetIdc) {\n            throw new Error('ttTargetIdc is required to send a message.');\n        }\n\n        return this.webClient.sendRoomChatFromEuler(\n            {\n                content: content,\n                roomId: roomId,\n                sessionId: sessionId,\n                ttTargetIdc: ttTargetIdc\n            }\n        );\n    }\n\n    /**\n     * Set up the WebSocket connection\n     *\n     * @param wsUrl WebSocket URL\n     * @param wsParams WebSocket parameters\n     * @returns Promise that will be resolved when the WebSocket connection is established\n     * @protected\n     */\n    protected async setupWebsocket(wsUrl: string, wsParams: WebSocketParams): Promise<TikTokWsClient> {\n        return new Promise<TikTokWsClient>((resolve, reject) => {\n\n            // Instantiate the client\n            const wsClient = new TikTokWsClient(\n                wsUrl,\n                this.webClient.cookieJar,\n                { ...Config.DEFAULT_WS_CLIENT_PARAMS, ...this.options.wsClientParams, ...wsParams },\n                { ...Config.DEFAULT_WS_CLIENT_HEADERS, ...this.options?.wsClientHeaders },\n                this.options?.wsClientOptions\n            );\n\n            // Handle the connection\n            wsClient.on('open', () => {\n                clearTimeout(connectTimeout);\n                wsClient.on('error', (e: any) => this.handleError(e, 'WebSocket Error'));\n                wsClient.on('close', () => {\n                    this.setDisconnected();\n                    this.emit(ControlEvent.DISCONNECTED);\n                });\n                resolve(wsClient);\n            });\n\n            wsClient.on('error', (err: any) => reject(`Websocket connection failed, ${err}`));\n            wsClient.on('protoMessageFetchResult', this.processProtoMessageFetchResult.bind(this));\n            wsClient.on('imEnteredRoom', (data: DecodedWebcastPushFrame) => this.emit(ControlEvent.ENTER_ROOM, data));\n            wsClient.on('webSocketData', (data: Uint8Array) => this.emit(ControlEvent.WEBSOCKET_DATA, data));\n            wsClient.on('messageDecodingFailed', (err: any) => this.handleError(err, 'Websocket message decoding failed'));\n            const connectTimeout = setTimeout(() => reject('Websocket not responding'), 20_000);\n        });\n    }\n\n    protected async processProtoMessageFetchResult(protoMessageFetchResult: ProtoMessageFetchResult): Promise<void> {\n\n        for (const message of protoMessageFetchResult.messages) {\n\n            if (!message.decodedData) {\n                continue;\n            }\n\n            // Emit the decoded data\n            this.emit(\n                ControlEvent.DECODED_DATA,\n                message.type,\n                message.decodedData,\n                message.payload\n            );\n\n            // Process & emit decoded data depending on the message type\n            try {\n                await this.processDecodedData(message.decodedData);\n            } catch (ex) {\n                this.handleError(ex, 'Failed to process decoded data');\n            }\n\n        }\n\n    }\n\n    protected async processDecodedData({ data, type }: DecodedData): Promise<boolean | void> {\n\n        // Emit a decoded data event\n        switch (type) {\n\n            case 'WebcastSocialMessage':\n\n                if (data.common.displayText.displayType?.includes('follow')) {\n                    return this.emit(WebcastEvent.FOLLOW, data);\n                }\n\n                if (data.common.displayText.displayType?.includes('share')) {\n                    return this.emit(WebcastEvent.SHARE, data);\n                }\n\n                // First, emit the raw social message\n                return this.emit(WebcastEvent.SOCIAL, data);\n\n            case 'WebcastControlMessage':\n\n                // Send raw message\n                this.emit(WebcastEvent.CONTROL_MESSAGE, data);\n\n                if (data.action === ControlAction.CONTROL_ACTION_STREAM_ENDED || data.action === ControlAction.CONTROL_ACTION_STREAM_SUSPENDED) {\n                    this.emit(WebcastEvent.STREAM_END, { action: data.action });\n                    await this.disconnect();\n                }\n\n                return;\n\n            case 'WebcastGiftMessage':\n\n                // Add extended gift info if available\n                if (Array.isArray(this.availableGifts) && data.giftId) {\n                    data.extendedGiftInfo = this.availableGifts.find((x) => x.id === data.giftId);\n                }\n\n                return this.emit(WebcastEvent.GIFT, data);\n            default:\n\n                // Handle all other events\n                const basicEvent = WebcastEventMap[type];\n                return basicEvent && this.emit(basicEvent, data);\n\n        }\n\n    }\n\n    /**\n     * Handle the error event\n     *\n     * @param exception Exception object\n     * @param info Additional information about the error\n     * @protected\n     */\n    protected handleError(exception: Error, info: string): void {\n        if (this.listenerCount(ControlEvent.ERROR) < 1) {\n            return;\n        }\n\n        this.emit(ControlEvent.ERROR, { info, exception });\n    }\n\n}\n\n\n"]}