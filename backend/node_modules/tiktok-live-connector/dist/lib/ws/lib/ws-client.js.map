{"version":3,"file":"ws-client.js","sourceRoot":"","sources":["../../../../src/lib/ws/lib/ws-client.ts"],"names":[],"mappings":"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","sourcesContent":["import { BinaryWriter } from '@bufbuild/protobuf/wire';\nimport { DecodedWebcastPushFrame, WebSocketParams } from '@/types/client';\nimport { createBaseWebcastPushFrame, deserializeWebSocketMessage } from '@/lib/utilities';\nimport Config from '@/lib/config';\nimport TypedEventEmitter from 'typed-emitter';\nimport CookieJar from '@/lib/web/lib/cookie-jar';\nimport { HeartbeatMessage, WebcastImEnterRoomMessage } from '@/types';\nimport { ClientOptions, WebSocket } from 'ws';\n\nconst textEncoder = new TextEncoder();\n\ntype EventMap = {\n    close: () => void;\n    messageDecodingFailed: (error: Error) => void;\n    protoMessageFetchResult: (response: any) => void;\n    webSocketData: (data: Buffer) => void;\n    imEnteredRoom: (decodedContainer: DecodedWebcastPushFrame) => void;\n};\n\ntype TypedWebSocket = new (...args: any[]) => WebSocket & TypedEventEmitter<EventMap>;\n\nexport default class TikTokWsClient extends (WebSocket as TypedWebSocket) {\n    protected pingInterval: NodeJS.Timeout | null;\n\n    constructor(\n        wsUrl: string,\n        cookieJar: CookieJar,\n        protected readonly webSocketParams: WebSocketParams,\n        webSocketHeaders: Record<string, string>,\n        webSocketOptions: ClientOptions,\n        protected webSocketPingIntervalMs: number = 10000\n    ) {\n        const wsHeaders = { Cookie: cookieJar.getCookieString(), ...(webSocketHeaders || {}) };\n        const wsUrlWithParams = `${wsUrl}?${new URLSearchParams(webSocketParams)}${Config.DEFAULT_WS_CLIENT_PARAMS_APPEND_PARAMETER}`;\n\n        super(\n            wsUrlWithParams,\n            {\n                headers: wsHeaders,\n                host: `https://${Config.TIKTOK_HOST_WEB}`,\n                ...webSocketOptions,\n                autoPong: false\n            }\n        );\n\n        this.pingInterval = null;\n        this.on('open', this.onOpen.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('close', this.onDisconnect.bind(this));\n    }\n\n    protected onOpen() {\n        this.sendHeartbeat();\n        this.pingInterval = setInterval(() => this.sendHeartbeat(), this.webSocketPingIntervalMs);\n    }\n\n    public get open(): boolean {\n        return this.readyState === WebSocket.OPEN;\n    }\n\n    /**\n     * Send a message to the WebSocket server\n     * @param data The message to send\n     * @returns True if the message was sent, false otherwise\n     */\n    public sendBytes(data: Uint8Array): boolean {\n        if (this.open) {\n            super.send(Buffer.from(data));\n            return true;\n        }\n        return false;\n    }\n\n    protected onDisconnect() {\n        clearInterval(this.pingInterval);\n        this.pingInterval = null;\n    }\n\n    /**\n     * Handle incoming messages\n     * @param message The incoming WebSocket message (type => Buffer)\n     * @protected\n     */\n    protected async onMessage(message: Buffer) {\n\n        // Emit WebSocket data\n        this.emit('webSocketData', message);\n\n        //  If the message is binary, decode it\n        try {\n            const decodedContainer: DecodedWebcastPushFrame = await deserializeWebSocketMessage(message);\n\n            // If the message has a decoded protoMessageFetchResult, emit it\n            if (decodedContainer.protoMessageFetchResult) {\n\n                // If it needs an ack, send the ack\n                if (decodedContainer.protoMessageFetchResult.needsAck) {\n                    this.sendAck(decodedContainer);\n                }\n\n                this.emit('protoMessageFetchResult', decodedContainer.protoMessageFetchResult);\n            }\n\n            // If it's a room enter, emit\n            if (decodedContainer.payloadType === 'im_enter_room_resp') {\n                this.emit('imEnteredRoom', decodedContainer);\n            }\n\n        } catch (err) {\n            this.emit('messageDecodingFailed', err);\n        }\n\n    }\n\n    /**\n     * Static Keep-Alive ping\n     */\n    protected sendHeartbeat() {\n        const { room_id } = this.webSocketParams;\n\n        // Create the heartbeat\n        const hb: BinaryWriter = HeartbeatMessage.encode({ roomId: room_id });\n\n        // Wrap it in the WebcastPushFrame\n        const webcastPushFrame: BinaryWriter = createBaseWebcastPushFrame(\n            {\n                payloadEncoding: 'pb',\n                payloadType: 'hb',\n                payload: hb.finish(),\n                service: undefined,\n                method: undefined,\n                headers: {}\n            }\n        );\n\n        this.sendBytes(Buffer.from(webcastPushFrame.finish()));\n    }\n\n    /**\n     * EXPERIMENTAL: Switch to a different TikTok LIVE room while connected to the WebSocket\n     * @param roomId The room ID to switch to\n     */\n    public switchRooms(roomId: string): void {\n\n        const imEnterRoomMessage: BinaryWriter = WebcastImEnterRoomMessage.encode(\n            {\n                roomId: roomId,\n                roomTag: '',\n                liveRegion: '',\n                liveId: '12', // Static value for all streams (via decompiled APK)\n                identity: 'audience',\n                cursor: '',\n                accountType: '0',\n                enterUniqueId: '',\n                filterWelcomeMsg: '0',\n                isAnchorContinueKeepMsg: false\n            }\n        );\n\n        const webcastPushFrame: BinaryWriter = createBaseWebcastPushFrame(\n            {\n                payloadEncoding: 'pb',\n                payloadType: 'im_enter_room',\n                payload: imEnterRoomMessage.finish()\n            }\n        );\n\n        this.sendBytes(Buffer.from(webcastPushFrame.finish()));\n\n    }\n\n\n    /**\n     * Acknowledge the message was received\n     */\n    protected sendAck({ logId, protoMessageFetchResult: { internalExt } }: DecodedWebcastPushFrame): void {\n\n        // Always send an ACK for the message\n        if (!logId) {\n            return;\n        }\n\n        const webcastPushFrame: BinaryWriter = createBaseWebcastPushFrame(\n            {\n                logId: logId,\n                payloadEncoding: 'pb',\n                payloadType: 'ack',\n                payload: textEncoder.encode(internalExt)\n            }\n        );\n\n        this.sendBytes(Buffer.from(webcastPushFrame.finish()));\n    }\n\n}\n\n"]}